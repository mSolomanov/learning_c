/* Все битовые операции по приоритету. От высшего к низшему
Приоритет логических (4) битовых операций ниже чем у операций сравнения, и существенно ниже обычных арифметических операций.
Приоритет сдвиговых (2) битовых операций одинаковый, но выше, чем операций сравнения и ниже чем у арифметических операций.

~ (NOT)  — Побитовое отрицание          | ~00001111 = 11110000 (Все 0 стали 1 и наоборот)
X ~
0 1
1 0

& (AND)  — Сброс битов (маскирование)   | 1111 & 1101 = 1101 (Принудительно обнулили 2-й бит)
x y &
0 0 0
0 1 0
1 0 0
1 1 1

^ (XOR)  — (Исключающее ИЛИ)            | 1010 ^ 1111 = 0101 (инвертирует биты только там, где в маске стоит 1. Там, где 0 — бит остается исходным.)
x y ^
0 0 0
0 1 1
1 0 1
1 1 0

| (OR)   — Установка битов              | 0010 | 1000 = 1010 (Принудительно выставили 4-й бит)
x y |
0 0 0
0 1 1
1 0 1
1 1 1

<< (Left)— Смещение влево               | 0001 << 2 = 0100 (Биты «уехали» влево, справа зашли нули)
>> (Right)— Смещение вправо             | 0100 >> 2 = 0001 (Биты «уехали» вправо, младшие исчезли)
*/

#include <stdio.h>

int main(void)
{
// пример операции NOT ~

    unsigned char var = 153;  // 10011001 (153)
    unsigned char not_v = ~var; // 01100110 (102)

    printf("(NOT ~) var = %d, not_v = %d\n", var, not_v);

// пример операции AND &

    unsigned char flags = 5; // 00000101
    unsigned char mask = 4;  // 00000100

    unsigned char res = flags & mask; //00000100

    printf("(AND &) res = %d\n", res);
// пример проверки on/off конкретного бита
    unsigned char flags_1 = 5;
    unsigned mask_1 = 4;

    if( (flags_1 & mask_1) == mask_1)
        printf("bit 2 is on\n");
    else
        printf("bit 2 is off\n");

// пример операции ИЛИ |
    unsigned char flags_2 = 9; // 00001001
    unsigned char mask_2 = 5;  // 00000101

    flags_2 = flags_2 | mask_2;// 00001101 = 13
    printf("(OR |) flags_2 = %d\n", flags_2);

// пример операции ИЛИ(XOR) ^
    unsigned char flags_3 = 9; // 00001001
    unsigned mask_3 = 1;       // 00000001

    flags_3 = flags_3 ^ mask_3; // 00001000 = 8
    flags_3 ^= mask_3;  //дважды примененная одна и та же маска возвращает исходное значение. т.е тут 9
    printf("(XOR ^) flags_3 = %d\n", flags_3);

// проверка четности нечетности числа путем наложения маски с помощью &
    int x_1 = 6;

    if (x_1 & 1) {
        printf("Нечетное (Odd)\n");
    } else {
        printf("Четное (Even)\n");
    }

// пример операций смещения (<< >>)
    unsigned char x = 40;   // 00101000
    printf("x = %d\n", x);  

    x = x >> 1;             // 00010100 = 20
    printf("x = %d\n", x);

    x = x >> 2;             // 00000101 = 5
    printf("x = %d\n", x);

    x = x >> 1;             // 00000010 = 2
    printf("x = %d\n", x);

    x = x >> 1;             // 00000001 = 1
    printf("x = %d\n", x);

    x = x << 1;             // 00000010 = 2 
    printf("x = %d\n", x);

    x = x << 2;             // 00001000 = 8
    printf("x = %d\n", x);

    // отрицательные числа сдвигаются слева направо и замещаются 1
    signed char x_3 = -128; // 1000 0000 
    x_3 = x_3 >> 2;         // 1110 0000 = -32
    printf("x_3 = %d\n", x_3);




    return 0;
}